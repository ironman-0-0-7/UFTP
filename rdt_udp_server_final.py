# -*- coding: utf-8 -*-
"""rdt_udp_server_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fuu_oOT_dJYRbYL814iP8lCAPz-Nsy1p
"""

import socket
from socket import timeout
import sys
import time
import os
import struct

serverName = 'localhost'

PortRecv = 15000
PortSend = 15001

BUFFER_SIZE = 2000

recv = (serverName, PortRecv)
send = (serverName, PortSend)

recv_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
send_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

recv_sock.bind(recv)

output_file = 5  # some random assignment
seq_from = -1
buffer_acks = []

def make_packet(seq,ack,data):
    seq_field = (seq).to_bytes(4,byteorder='big')
    ack_field = (ack).to_bytes(4,byteorder='big')
    packet =  seq_field + ack_field + data
    return packet

def update_queue(recv_packets):
    global seq_from
    global output_file
    global buffer_acks
    if len(recv_packets)>0:
        buffer_acks += recv_packets
    buffer_acks = list(set(buffer_acks))
    buffer_acks.sort()
    last_ack = buffer_acks[-1][0]
    while len(buffer_acks)>0:
        if buffer_acks[0][0]<=seq_from:
            buffer_acks.pop(0)
        elif buffer_acks[0][0]==seq_from+1:
            print("Writing to file seq number:{}".format(buffer_acks[0][0]))
            output_file.write(buffer_acks[0][1])
            buffer_acks.pop(0)
            seq_from += 1
        else:
            break
    
    # making the neg acks into a packet
    neg_seqs = set(range(seq_from+1, last_ack+1))
    buffer_seqs = []
    for i in buffer_acks:
        buffer_seqs += [i[0]]
    buffer_seqs = set(buffer_seqs)
    neg_seqs -= buffer_seqs
    ans = [str(x) for x in neg_seqs]
    return ",".join(ans), last_ack

def upld(file_name):
    global seq_from
    global output_file
    global buffer_acks
    seq_from = -1
    output_file = open(file_name, "wb")
    last_ack_packet = None
    recv_packets = []
    buffer_acks = []
    transmission_complete = False
    while not transmission_complete or len(buffer_acks)>0:
        recv_packets = []
        recv_sock.settimeout(3) # timeout 1
        while True:
            try:
                recv_sock.settimeout(3)
                print("waiting...")
                message, address = recv_sock.recvfrom(BUFFER_SIZE)
                seq = int.from_bytes(message[:4],byteorder='big')
                ack = int.from_bytes(message[4:8],byteorder='big')
                #print(seq, ack)
                if ack==seq and seq >0:
                    transmission_complete = True
                recv_packets += [ (int.from_bytes(message[:4],byteorder='big'), message[8:]) ] # Storing (seq, data)
                #print("recieved:{}".format(int.from_bytes(message[:4],byteorder='big')))
                break 
            except timeout:
                if last_ack_packet:
                    send_sock.sendto(last_ack_packet,send)
                if transmission_complete:
                    break
        recv_sock.settimeout(1) # different from prev timeout
        while True:
            try:
                message, address = recv_sock.recvfrom(BUFFER_SIZE)
                seq = int.from_bytes(message[:4],byteorder='big')
                ack = int.from_bytes(message[4:8],byteorder='big')
                print(seq, ack)
                if ack==seq and seq >0:
                    transmission_complete = True
                recv_packets += [ (int.from_bytes(message[:4],byteorder='big'), message[8:]) ]
                #print("recieved:{}".format(int.from_bytes(message[:4],byteorder='big')))
                if transmission_complete:
                    break
            except timeout:
                break
        print("Number of received packets:{}".format(len(recv_packets)))
        neg_seqs, last_ack = update_queue(recv_packets)
        print("Negative ACKs count:{}".format(len(neg_seqs)))
        print("Last successful transmission sequence number:{}".format(last_ack))
        last_ack_packet = make_packet(last_ack, last_ack, neg_seqs.encode())
        send_sock.sendto(last_ack_packet,send)
        print("Sent neg acks")
    output_file.close()
    print("Transfer Complete")

def upld_p():
    
    # Send message once server is ready to recieve file details
    conn.sendall(b"1")
    # Recieve file name length, then file name
    file_name_size = struct.unpack("h", conn.recv(2))[0]
    file_name = conn.recv(file_name_size).decode('UTF-8')
    # Send message to let client know server is ready for document content
    conn.sendall(b"1")
    # Recieve file size
    file_size = struct.unpack("i", conn.recv(4))[0]
    # Initialise and enter loop to recive file content
    #print("file name :",file_name)
    return file_name

print ("\nWelcome to the FTP server.\n\nTo get started, connect a client.")

# Initialise socket stuff
TCP_IP = "127.0.0.1" # Only a local server

CP_PORT_SERV = 2031 # CONTROL PROCESS PORT


BUFFER_SIZE = 1024 # Standard size

cp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
cp.bind((TCP_IP, CP_PORT_SERV))
cp.listen()
conn, addr = cp.accept()

print ("\nConnected to by address: {}".format(addr))


def quit():
    # Send quit conformation
    conn.send(b"1")
    # Close and restart the server
    conn.close()
    recv_sock.close()
    send_sock.close()
    print('connection closed')
    #os.execl(sys.executable, sys.executable, *sys.argv)

while True:
    # Enter into a while loop to recieve commands from client
    print ("\n\nWaiting for instruction")
    mode = conn.recv(BUFFER_SIZE).decode('UTF-8')
    print ("\nRecieved instruction: {}".format(mode))
    # Check the command and respond correctly
    if mode == "UPLD":
        file_name=upld_p()
        upld(file_name)
    elif mode == "QUIT":
        quit()
        break
    # Reset the data to loop
    mode = None